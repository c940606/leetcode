class Solution(object):
	def rob(self, nums):
		"""
		你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，
		影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
		给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
		---
		输入: [1,2,3,1]
		输出: 4
		解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
			 偷窃到的最高金额 = 1 + 3 = 4 。
		---
		输入: [2,7,9,3,1]
		输出: 12
		解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
			 偷窃到的最高金额 = 2 + 9 + 1 = 12 。
		---
		思路:
		动态规划 如果只有第一家 有过 有两家 ....
		前面两个 第一家 直接偷
				有两家 与第一家比较
		三个以上 就要 只偷自己 max(前前一家+这家,和前一家)
		:type nums: List[int]
		:rtype: int
		"""
		res = []
		i = 0
		n = len(nums)
		while i < n:
			if i ==0:
				res.append(nums[i])
				i += 1
				continue
			if i == 1:
				res.append(max(res[i-1],nums[i]))
				i+= 1
				continue
			res.append(max(res[i-2]+nums[i],res[i-1]))
			i += 1
		return res[-1]
a = Solution()
print(a.rob([1,2,3,1]))

